#!/usr/bin/env perl

use strict;
use warnings;
use Nagios::Plugin::Functions;
use Nagios::Plugin::Getopt;
use Data::Validate::Domain qw/ is_hostname /;
use DateTime;

my $VERSION = '0.2.0';

    # Definitions
my $modes = {
    scan    => 1,
    report  => 1,
};
    # Define numeric values for scores
my $scores = {
    'A+'    => '1000',
    'A'     => '900',
    'A-'    => '800',
    'B'     => '700',
    'C'     => '600',
    'D'     => '500',
    'E'     => '400',
    'F'     => '300',
    'T'     => '200'
};



    # Get arguments
my $go = Nagios::Plugin::Getopt->new(
    usage       => "Usage: %s -H <hostname> --mode=(scan|report) [ -w <warning> -c <critical> -s </path/to/ssllabs-scan> -r /path/to/report-file -C -a 24 ]",
    version     => $VERSION,
    url         => 'https://github.com/alasdairkeyes/nagios-plugin-check_cert_ssllabs',
    blurb       => "Check a website's SSL config against the SSLLabs API.",
    'timeout'   => 150,
);

$go->arg(
    spec        => 'critical|c=s',
    help        => q(Exit with CRITICAL status if score is less than or equal to this score),
    required    => 1,
    default     => 'A-',
);

$go->arg(
    spec        => 'warning|w=s',
    help        => q(Exit with WARNING status if score is less than or equal to this score),
    required    => 1,
    default     => 'A',
);
    
$go->arg(
    spec        => 'hostname|H=s',
    help        => q(Provide the hostname to scan - DNS must be set up),
    required    => 1,
);

$go->arg(
    spec        => 'scantool|s=s',
    help        => q(Provide the path to the ssllabs-scan tool),
    required    => 0,
    default     => '/usr/local/bin/ssllabs-scan',
);

$go->arg(
    spec        => 'usecache|C',
    help        => q(Use a cached test from SSL labs if one has been run recently),
    required    => 0,
);

$go->arg(
    spec        => 'mode|m=s',
    help        => 'Mode that the script should run, options are ' . join(',', sort(keys(%$modes))),
    required    => 1,
);

$go->arg(
    spec        => 'reportfile|r=s',
    help        => 'The file that the scan should output to',
    required    => 0,
    default     => '/tmp/check_cert_ssllabs_<hostname>.report'
);

$go->arg(
    spec        => 'age|a=i',
    help        => 'The amount of time in hours that the scan should be considered valid for.',
    required    => 0,
    default     => 24,
);

$go->getopts;

my $mode        = $go->mode; 
my $scantool    = $go->scantool;
my $hostname    = $go->hostname;
my $critical    = uc($go->critical);
my $warning     = uc($go->warning);
my $report_file = $go->reportfile;
$report_file =~ s/<hostname>/$hostname/g;
my $age         = $go->age;

my $now = DateTime->now(
    time_zone => 'local'
);

check_arguments();


if ($mode eq 'scan') {
    scan();
} elsif ($mode eq 'report') {
    report();
}

    # Both scan, report functions exit, this is just for readability
exit;


    # Scan mode
sub scan {
    my $output;
    eval {
        local $SIG{ALRM} = sub { die "alarm\n" };
        alarm $go->timeout;
        $output = `$scantool --quiet --grade $hostname`;
        alarm 0;
    };

    my $score;

    if ($@ && $@ eq "alarm\n") {
        $score = 'Timeout';
    } else {
        $score = parse_output($output)
            || 'Error';
    }

    open (my $fh, '>', $report_file)
        || nagios_exit ( CRITICAL, "Failed to open '$report_file': $!" );


    print $fh join(':', $now->epoch, $score);
    close $fh;
    exit 0;
}

    # Report mode
sub report {
    open (my $fh, '<', $report_file)
        || nagios_exit ( CRITICAL, "Failed to open '$report_file': $!" );

    my $line = <$fh>;
    close $fh;
    $line =~ s/\n//g;
    my ($epoch, $score) = split(/:/, $line);

    my $datetime = DateTime->from_epoch(
        epoch   => $epoch,
        time_zone   => 'local'
    );

    nagios_exit ( CRITICAL, 'Scan date of ' . $datetime->datetime . ' is too old')
        if ($datetime->epoch + ($age * 60 * 60) < $now->epoch);

    my $value = score_to_value($score);

    my $exit_value = OK;
    if ($value <= $scores->{ $critical }) {
        $exit_value = CRITICAL;
    } elsif ($value <= $scores->{ $warning }) {
        $exit_value = WARNING;
    }

    nagios_exit ( $exit_value, "$hostname :: Score $score");
    
}



    # Check user supplied arguments
sub check_arguments {

    nagios_exit( CRITICAL, 'Invalid mode' )
        unless ($modes->{ $mode });

    nagios_exit( CRITICAL, 'Invalid hostname')
        unless (is_hostname($hostname));


    if ($mode eq 'scan') {

        nagios_exit( CRITICAL, 'ssllabs-scan path is not executable')
            unless (-x $scantool);
        my $use_cache = '--usecache=true'
            if ($go->usecache);

    } elsif ($mode eq 'report') {

        nagios_exit( CRITICAL, 'Invalid critical value')
            unless ($scores->{ $critical });
        nagios_exit( WARNING, 'Invalid warning value')
            unless ($scores->{ $warning });
        nagios_exit( CRITICAL, "Critical value must be lower than warning")
            if ($scores->{ $critical } > $scores->{ $warning });
    }
}


    # Take output and return the score
sub parse_output {
    my $output = shift;
    my ($first_line, @other) = split(/\n/, $output);
    my @results = split(/:/, $first_line);
    my $host    = $results[0] || '';
    my $score   = $results[1] || '';
    $score =~ s/[" ]+//g;
    return $score;
}


    # Convert score to a numerical value
sub score_to_value {
    my $score = shift;
    return $scores->{ uc($score) } || '';
}
