#!/usr/bin/env perl

use strict;
use warnings;
use Nagios::Plugin::Functions;
use Nagios::Plugin::Getopt;
use Data::Validate::Domain qw/ is_hostname /;

my $VERSION = '0.1.0';

    # Get arguments
my $go = Nagios::Plugin::Getopt->new(
    usage       => "Usage: %s -H <hostname> [ -w <warning> -c <critical> -s </path/tossllabs-scan> -C ]",
    version     => $VERSION,
    url         => 'https://github.com/alasdairkeyes/nagios-plugin-check_cert_ssllabs',
    blurb       => "Check a website's SSL config against the SSLLabs API.",
    'timeout'   => 150,
);

$go->arg(
    spec        => 'critical|c=s',
    help        => q(Exit with CRITICAL status if score is less than or equal to this score),
    required    => 1,
    default     => 'A-',
);

$go->arg(
    spec        => 'warning|w=s',
    help        => q(Exit with WARNING status if score is less than or equal to this score),
    required    => 1,
    default     => 'A',
);
    
$go->arg(
    spec        => 'hostname|H=s',
    help        => q(Provide the hostname to scan - DNS must be set up),
    required    => 1,
);

$go->arg(
    spec        => 'scantool|s=s',
    help        => q(Provide the path to the ssllabs-scan tool),
    required    => 0,
    default     => '/usr/local/bin/ssllabs-scan',
);

$go->arg(
    spec        => 'usecache|C',
    help        => q(Use a cached test from SSL labs if one has been run recently),
    required    => 0,
);

$go->getopts;

my $scantool    = $go->scantool;
my $hostname    = $go->hostname;
my $critical    = uc($go->critical);
my $warning     = uc($go->warning);


    # Define numeric values for scores
my $scores = {
    'A+'    => '1000',
    'A'     => '900',
    'A-'    => '800',
    'B'     => '700',
    'C'     => '600',
    'D'     => '500',
    'E'     => '400',
    'F'     => '300',
    'T'     => '200'
};


check_arguments();

    # Run tool
my $output;
eval {
    local $SIG{ALRM} = sub { die "alarm\n" };
    alarm $go->timeout;
    $output = `$scantool --quiet --grade $hostname`;
    alarm 0;
};

nagios_exit ( CRITICAL, "Timeout" )
    if ($@ && $@ eq "alarm\n");

    # Get output
my $score = parse_output($output);
my $value = score_to_value($score);

nagios_exit( CRITICAL, "Unknown score '$score'")
    unless $value;

my $exit_value = OK;
if ($scores->{ uc($score) } <= $scores->{ $critical }) {
    $exit_value = CRITICAL;
} elsif ($scores->{ uc($score) } <= $scores->{ $warning }) {
    $exit_value = WARNING;
}

nagios_exit ( $exit_value, "Score $score");


    # Check user supplied arguments
sub check_arguments {
    nagios_exit( CRITICAL, 'Invalid hostname')
        unless (is_hostname($hostname));
    nagios_exit( CRITICAL, 'ssllabs-scan path is not executable')
        unless (-x $scantool);
    nagios_exit( CRITICAL, 'Invalid critical value')
        unless ($scores->{ $critical });
    nagios_exit( WARNING, 'Invalid warning value')
        unless ($scores->{ $warning });
    my $use_cache = '--usecache=true'
        if ($go->usecache);

    nagios_exit( CRITICAL, "Critical value must be lower than warning")
        if ($scores->{ $critical } > $scores->{ $warning });
}


    # Take output and return the score
sub parse_output {
    my $output = shift;
    my ($first_line, @other) = split(/\n/, $output);
    my @results = split(/:/, $first_line);
    my $host    = $results[0] || '';
    my $score   = $results[1] || '';
    $score =~ s/[" ]+//g;
    return $score;
}


    # Convert score to a numerical value
sub score_to_value {
    my $score = shift;
    return $scores->{ uc($score) } || '';
}
